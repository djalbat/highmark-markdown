"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return importer;
    },
    defaultContent: function() {
        return defaultContent;
    }
});
var _index = require("../index");
var _constants = require("./constants");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var markdownLexer = _index.MarkdownLexer.fromNothing(), markdownParser = _index.MarkdownParser.fromNothing();
function importer(filePath, context) {
    var content = contentMap[filePath] || null;
    if (content !== null) {
        var startRule = markdownParser.getStartRule(), tokens = markdownLexer.tokenise(content), node = markdownParser.parse(tokens, startRule), importedNode = node, importedTokens = tokens, importedClassName = classNameFromFilePath(filePath);
        Object.assign(context, {
            importedNode: importedNode,
            importedTokens: importedTokens,
            importedClassName: importedClassName
        });
    }
}
function classNameFromFilePath(filePath) {
    var className = filePath.replace(/\.md/, _constants.EMPTY_STRING);
    return className;
}
var INDEX_PATH = "index.md", CONTENT_PATH = "content.md", CONTENTS_PATH = "contents.md", HALF_TITLE_PATH = "half-title.md", FRONT_MATTER_PATH = "front-matter.md", INTRODUCTION_PATH = "introduction.md", GETTING_STARTED_PATH = "getting-started.md", INSTALLING_THE_CLI_PATH = "installing-the-cli.md", GETTING_TO_GRIPS_WITH_THE_IDE_PATH = "getting-to-grips-with-the-ide.md";
var defaultContent = "@ignore\n\n@include ".concat(FRONT_MATTER_PATH, "\n@include ").concat(CONTENT_PATH, "\n@include ").concat(INDEX_PATH, "\n");
var indexContent = "## Index\n\n@index", contentContent = "@ignore\n\n@include ".concat(INTRODUCTION_PATH, "\n@include ").concat(GETTING_STARTED_PATH), contentsContent = "## Contents\n\n@contents", halfTitleContent = "# Occam", frontMatterContent = "@ignore\n\n@include ".concat(HALF_TITLE_PATH, "\n@include ").concat(CONTENTS_PATH), introductionContent = "# Introduction\n      \nConstructor.\n\n@footnotes\n\n@pageNumber\n", gettingStartedContent = "# Getting started\n      \nAnother short paragraph with a reference to a footnote[^occam].\n\n[^occam]: The word Occam is used somewhat nebulously here.\nIt is most often associated with Occam's IDE but in fact it encompasses a range of software and services.\nThis book explains these divers parts and there is a companion book, called The Foundations of Symbolic Reasoning, that covers the underlying theory.\n\n[^florence]: Occam was originally called Florence but the former seemed more apt.\n\n@footnotes\n\n@embed ".concat(INSTALLING_THE_CLI_PATH, "\n@embed ").concat(GETTING_TO_GRIPS_WITH_THE_IDE_PATH, "\n\n@pageNumber\n"), installingTheCLIContent = "## Installing the CLI\n", gettingToGripsWithTheIDEIContent = "## Getting to grips with the IDE\n            \n* An unordered list to test...\n* ...the indexing.\n      \n1. As well as an...\n2. ...ordered list.\n      \n";
var _obj;
var contentMap = (_obj = {}, _define_property(_obj, INDEX_PATH, indexContent), _define_property(_obj, CONTENT_PATH, contentContent), _define_property(_obj, CONTENTS_PATH, contentsContent), _define_property(_obj, HALF_TITLE_PATH, halfTitleContent), _define_property(_obj, FRONT_MATTER_PATH, frontMatterContent), _define_property(_obj, INTRODUCTION_PATH, introductionContent), _define_property(_obj, GETTING_STARTED_PATH, gettingStartedContent), _define_property(_obj, INSTALLING_THE_CLI_PATH, installingTheCLIContent), _define_property(_obj, GETTING_TO_GRIPS_WITH_THE_IDE_PATH, gettingToGripsWithTheIDEIContent), _obj);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9leGFtcGxlL2ltcG9ydGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBNYXJrZG93bkxleGVyLCBNYXJrZG93blBhcnNlciB9IGZyb20gXCIuLi9pbmRleFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgbWFya2Rvd25MZXhlciA9IE1hcmtkb3duTGV4ZXIuZnJvbU5vdGhpbmcoKSxcbiAgICAgIG1hcmtkb3duUGFyc2VyID0gTWFya2Rvd25QYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW1wb3J0ZXIoZmlsZVBhdGgsIGNvbnRleHQpIHtcbiAgY29uc3QgY29udGVudCA9IGNvbnRlbnRNYXBbZmlsZVBhdGhdIHx8IG51bGw7XG5cbiAgaWYgKGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICBjb25zdCBzdGFydFJ1bGUgPSBtYXJrZG93blBhcnNlci5nZXRTdGFydFJ1bGUoKSxcbiAgICAgICAgICB0b2tlbnMgPSBtYXJrZG93bkxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIG5vZGUgPSBtYXJrZG93blBhcnNlci5wYXJzZSh0b2tlbnMsIHN0YXJ0UnVsZSksXG4gICAgICAgICAgaW1wb3J0ZWROb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIGltcG9ydGVkVG9rZW5zID0gdG9rZW5zLFxuICAgICAgICAgIGltcG9ydGVkQ2xhc3NOYW1lID0gY2xhc3NOYW1lRnJvbUZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgIE9iamVjdC5hc3NpZ24oY29udGV4dCwge1xuICAgICAgaW1wb3J0ZWROb2RlLFxuICAgICAgaW1wb3J0ZWRUb2tlbnMsXG4gICAgICBpbXBvcnRlZENsYXNzTmFtZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsYXNzTmFtZUZyb21GaWxlUGF0aChmaWxlUGF0aCkge1xuICBjb25zdCBjbGFzc05hbWUgPSBmaWxlUGF0aC5yZXBsYWNlKC9cXC5tZC8sIEVNUFRZX1NUUklORyk7XG5cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuY29uc3QgSU5ERVhfUEFUSCA9IFwiaW5kZXgubWRcIixcbiAgICAgIENPTlRFTlRfUEFUSCA9IFwiY29udGVudC5tZFwiLFxuICAgICAgQ09OVEVOVFNfUEFUSCA9IFwiY29udGVudHMubWRcIixcbiAgICAgIEhBTEZfVElUTEVfUEFUSCA9IFwiaGFsZi10aXRsZS5tZFwiLFxuICAgICAgRlJPTlRfTUFUVEVSX1BBVEggPSBcImZyb250LW1hdHRlci5tZFwiLFxuICAgICAgSU5UUk9EVUNUSU9OX1BBVEggPSBcImludHJvZHVjdGlvbi5tZFwiLFxuICAgICAgR0VUVElOR19TVEFSVEVEX1BBVEggPSBcImdldHRpbmctc3RhcnRlZC5tZFwiLFxuICAgICAgSU5TVEFMTElOR19USEVfQ0xJX1BBVEggPSBcImluc3RhbGxpbmctdGhlLWNsaS5tZFwiLFxuICAgICAgR0VUVElOR19UT19HUklQU19XSVRIX1RIRV9JREVfUEFUSCA9IFwiZ2V0dGluZy10by1ncmlwcy13aXRoLXRoZS1pZGUubWRcIjtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRDb250ZW50ID0gYEBpZ25vcmVcblxuQGluY2x1ZGUgJHtGUk9OVF9NQVRURVJfUEFUSH1cbkBpbmNsdWRlICR7Q09OVEVOVF9QQVRIfVxuQGluY2x1ZGUgJHtJTkRFWF9QQVRIfVxuYDtcblxuY29uc3QgaW5kZXhDb250ZW50ID0gYCMjIEluZGV4XG5cbkBpbmRleGAsXG5cbiAgICAgIGNvbnRlbnRDb250ZW50ID0gYEBpZ25vcmVcblxuQGluY2x1ZGUgJHtJTlRST0RVQ1RJT05fUEFUSH1cbkBpbmNsdWRlICR7R0VUVElOR19TVEFSVEVEX1BBVEh9YCxcblxuICAgICAgY29udGVudHNDb250ZW50ID0gYCMjIENvbnRlbnRzXG5cbkBjb250ZW50c2AsXG5cbiAgICAgIGhhbGZUaXRsZUNvbnRlbnQgPSBgIyBPY2NhbWAsXG5cbiAgICAgIGZyb250TWF0dGVyQ29udGVudCA9IGBAaWdub3JlXG5cbkBpbmNsdWRlICR7SEFMRl9USVRMRV9QQVRIfVxuQGluY2x1ZGUgJHtDT05URU5UU19QQVRIfWAsXG5cbiAgICAgIGludHJvZHVjdGlvbkNvbnRlbnQgPSBgIyBJbnRyb2R1Y3Rpb25cbiAgICAgIFxuQ29uc3RydWN0b3IuXG5cbkBmb290bm90ZXNcblxuQHBhZ2VOdW1iZXJcbmAsXG5cbiAgICAgIGdldHRpbmdTdGFydGVkQ29udGVudCA9IGAjIEdldHRpbmcgc3RhcnRlZFxuICAgICAgXG5Bbm90aGVyIHNob3J0IHBhcmFncmFwaCB3aXRoIGEgcmVmZXJlbmNlIHRvIGEgZm9vdG5vdGVbXm9jY2FtXS5cblxuW15vY2NhbV06IFRoZSB3b3JkIE9jY2FtIGlzIHVzZWQgc29tZXdoYXQgbmVidWxvdXNseSBoZXJlLlxuSXQgaXMgbW9zdCBvZnRlbiBhc3NvY2lhdGVkIHdpdGggT2NjYW0ncyBJREUgYnV0IGluIGZhY3QgaXQgZW5jb21wYXNzZXMgYSByYW5nZSBvZiBzb2Z0d2FyZSBhbmQgc2VydmljZXMuXG5UaGlzIGJvb2sgZXhwbGFpbnMgdGhlc2UgZGl2ZXJzIHBhcnRzIGFuZCB0aGVyZSBpcyBhIGNvbXBhbmlvbiBib29rLCBjYWxsZWQgVGhlIEZvdW5kYXRpb25zIG9mIFN5bWJvbGljIFJlYXNvbmluZywgdGhhdCBjb3ZlcnMgdGhlIHVuZGVybHlpbmcgdGhlb3J5LlxuXG5bXmZsb3JlbmNlXTogT2NjYW0gd2FzIG9yaWdpbmFsbHkgY2FsbGVkIEZsb3JlbmNlIGJ1dCB0aGUgZm9ybWVyIHNlZW1lZCBtb3JlIGFwdC5cblxuQGZvb3Rub3Rlc1xuXG5AZW1iZWQgJHtJTlNUQUxMSU5HX1RIRV9DTElfUEFUSH1cbkBlbWJlZCAke0dFVFRJTkdfVE9fR1JJUFNfV0lUSF9USEVfSURFX1BBVEh9XG5cbkBwYWdlTnVtYmVyXG5gLFxuXG4gICAgICBpbnN0YWxsaW5nVGhlQ0xJQ29udGVudCA9IGAjIyBJbnN0YWxsaW5nIHRoZSBDTElcbmAsXG5cbiAgICAgIGdldHRpbmdUb0dyaXBzV2l0aFRoZUlERUlDb250ZW50ID0gYCMjIEdldHRpbmcgdG8gZ3JpcHMgd2l0aCB0aGUgSURFXG4gICAgICAgICAgICBcbiogQW4gdW5vcmRlcmVkIGxpc3QgdG8gdGVzdC4uLlxuKiAuLi50aGUgaW5kZXhpbmcuXG4gICAgICBcbjEuIEFzIHdlbGwgYXMgYW4uLi5cbjIuIC4uLm9yZGVyZWQgbGlzdC5cbiAgICAgIFxuYDtcblxuY29uc3QgY29udGVudE1hcCA9IHtcblxuICBbSU5ERVhfUEFUSF06IGluZGV4Q29udGVudCxcbiAgW0NPTlRFTlRfUEFUSF06IGNvbnRlbnRDb250ZW50LFxuICBbQ09OVEVOVFNfUEFUSF06IGNvbnRlbnRzQ29udGVudCxcbiAgW0hBTEZfVElUTEVfUEFUSF06IGhhbGZUaXRsZUNvbnRlbnQsXG4gIFtGUk9OVF9NQVRURVJfUEFUSF06IGZyb250TWF0dGVyQ29udGVudCxcbiAgW0lOVFJPRFVDVElPTl9QQVRIXTogaW50cm9kdWN0aW9uQ29udGVudCxcbiAgW0dFVFRJTkdfU1RBUlRFRF9QQVRIXTogZ2V0dGluZ1N0YXJ0ZWRDb250ZW50LFxuICBbSU5TVEFMTElOR19USEVfQ0xJX1BBVEhdOiBpbnN0YWxsaW5nVGhlQ0xJQ29udGVudCxcbiAgW0dFVFRJTkdfVE9fR1JJUFNfV0lUSF9USEVfSURFX1BBVEhdOiBnZXR0aW5nVG9Hcmlwc1dpdGhUaGVJREVJQ29udGVudFxuXG59O1xuIl0sIm5hbWVzIjpbImltcG9ydGVyIiwiZGVmYXVsdENvbnRlbnQiLCJtYXJrZG93bkxleGVyIiwiTWFya2Rvd25MZXhlciIsImZyb21Ob3RoaW5nIiwibWFya2Rvd25QYXJzZXIiLCJNYXJrZG93blBhcnNlciIsImZpbGVQYXRoIiwiY29udGV4dCIsImNvbnRlbnQiLCJjb250ZW50TWFwIiwic3RhcnRSdWxlIiwiZ2V0U3RhcnRSdWxlIiwidG9rZW5zIiwidG9rZW5pc2UiLCJub2RlIiwicGFyc2UiLCJpbXBvcnRlZE5vZGUiLCJpbXBvcnRlZFRva2VucyIsImltcG9ydGVkQ2xhc3NOYW1lIiwiY2xhc3NOYW1lRnJvbUZpbGVQYXRoIiwiT2JqZWN0IiwiYXNzaWduIiwiY2xhc3NOYW1lIiwicmVwbGFjZSIsIkVNUFRZX1NUUklORyIsIklOREVYX1BBVEgiLCJDT05URU5UX1BBVEgiLCJDT05URU5UU19QQVRIIiwiSEFMRl9USVRMRV9QQVRIIiwiRlJPTlRfTUFUVEVSX1BBVEgiLCJJTlRST0RVQ1RJT05fUEFUSCIsIkdFVFRJTkdfU1RBUlRFRF9QQVRIIiwiSU5TVEFMTElOR19USEVfQ0xJX1BBVEgiLCJHRVRUSU5HX1RPX0dSSVBTX1dJVEhfVEhFX0lERV9QQVRIIiwiaW5kZXhDb250ZW50IiwiY29udGVudENvbnRlbnQiLCJjb250ZW50c0NvbnRlbnQiLCJoYWxmVGl0bGVDb250ZW50IiwiZnJvbnRNYXR0ZXJDb250ZW50IiwiaW50cm9kdWN0aW9uQ29udGVudCIsImdldHRpbmdTdGFydGVkQ29udGVudCIsImluc3RhbGxpbmdUaGVDTElDb250ZW50IiwiZ2V0dGluZ1RvR3JpcHNXaXRoVGhlSURFSUNvbnRlbnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztJQVNBLE9BaUJDO2VBakJ1QkE7O0lBbUNYQyxjQUFjO2VBQWRBOzs7cUJBMUNpQzt5QkFFakI7Ozs7Ozs7Ozs7Ozs7O0FBRTdCLElBQU1DLGdCQUFnQkMsb0JBQWEsQ0FBQ0MsV0FBVyxJQUN6Q0MsaUJBQWlCQyxxQkFBYyxDQUFDRixXQUFXO0FBRWxDLFNBQVNKLFNBQVNPLFFBQVEsRUFBRUMsT0FBTztJQUNoRCxJQUFNQyxVQUFVQyxVQUFVLENBQUNILFNBQVMsSUFBSTtJQUV4QyxJQUFJRSxZQUFZLE1BQU07UUFDcEIsSUFBTUUsWUFBWU4sZUFBZU8sWUFBWSxJQUN2Q0MsU0FBU1gsY0FBY1ksUUFBUSxDQUFDTCxVQUNoQ00sT0FBT1YsZUFBZVcsS0FBSyxDQUFDSCxRQUFRRixZQUNwQ00sZUFBZUYsTUFDZkcsaUJBQWlCTCxRQUNqQk0sb0JBQW9CQyxzQkFBc0JiO1FBRWhEYyxPQUFPQyxNQUFNLENBQUNkLFNBQVM7WUFDckJTLGNBQUFBO1lBQ0FDLGdCQUFBQTtZQUNBQyxtQkFBQUE7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTQyxzQkFBc0JiLFFBQVE7SUFDckMsSUFBTWdCLFlBQVloQixTQUFTaUIsT0FBTyxDQUFDLFFBQVFDLHVCQUFZO0lBRXZELE9BQU9GO0FBQ1Q7QUFFQSxJQUFNRyxhQUFhLFlBQ2JDLGVBQWUsY0FDZkMsZ0JBQWdCLGVBQ2hCQyxrQkFBa0IsaUJBQ2xCQyxvQkFBb0IsbUJBQ3BCQyxvQkFBb0IsbUJBQ3BCQyx1QkFBdUIsc0JBQ3ZCQywwQkFBMEIseUJBQzFCQyxxQ0FBcUM7QUFFcEMsSUFBTWpDLGlCQUFpQixBQUFDLHVCQUdwQjBCLE9BREFHLG1CQUFrQixlQUVsQkosT0FEQUMsY0FBYSxlQUNGLE9BQVhELFlBQVc7QUFHdEIsSUFBTVMsZUFBZ0Isc0JBSWhCQyxpQkFBaUIsQUFBQyx1QkFHYkosT0FEQUQsbUJBQWtCLGVBQ0csT0FBckJDLHVCQUVMSyxrQkFBbUIsNEJBSW5CQyxtQkFBb0IsV0FFcEJDLHFCQUFxQixBQUFDLHVCQUdqQlgsT0FEQUMsaUJBQWdCLGVBQ0YsT0FBZEQsZ0JBRUxZLHNCQUF1Qix1RUFTdkJDLHdCQUF3QixBQUFDLDJnQkFhdEJQLE9BREFELHlCQUF3QixhQUNXLE9BQW5DQyxvQ0FBbUMsc0JBS3RDUSwwQkFBMkIsMkJBRzNCQyxtQ0FBb0M7SUFVdkI7QUFBbkIsSUFBTWpDLGNBQWEsV0FFakIsaUJBRmlCLE1BRWhCZ0IsWUFBYVMsZUFDZCxpQkFIaUIsTUFHaEJSLGNBQWVTLGlCQUNoQixpQkFKaUIsTUFJaEJSLGVBQWdCUyxrQkFDakIsaUJBTGlCLE1BS2hCUixpQkFBa0JTLG1CQUNuQixpQkFOaUIsTUFNaEJSLG1CQUFvQlMscUJBQ3JCLGlCQVBpQixNQU9oQlIsbUJBQW9CUyxzQkFDckIsaUJBUmlCLE1BUWhCUixzQkFBdUJTLHdCQUN4QixpQkFUaUIsTUFTaEJSLHlCQUEwQlMsMEJBQzNCLGlCQVZpQixNQVVoQlIsb0NBQXFDUyxtQ0FWckIifQ==