"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    contentFromNode: function() {
        return contentFromNode;
    },
    contentFromNodeAndTokens: function() {
        return contentFromNodeAndTokens;
    },
    contentFromNodes: function() {
        return contentFromNodes;
    },
    default: function() {
        return _default;
    },
    remainingContentFromNodeTokensAndOffset: function() {
        return remainingContentFromNodeTokensAndOffset;
    }
});
var _necessary = require("necessary");
var _constants = require("../constants");
var _tokenTypes = require("../tokenTypes");
var first = _necessary.arrayUtilities.first, last = _necessary.arrayUtilities.last;
function contentFromNode(node, context) {
    var content = _constants.EMPTY_STRING;
    var tokens = context.tokens;
    var lastSignificantToken = node.getLastSignificantToken(), firstSignificantToken = node.getFirstSignificantToken(), lastSignificantTokenIndex = tokens.indexOf(lastSignificantToken), firstSignificantTokenIndex = tokens.indexOf(firstSignificantToken);
    var start = firstSignificantTokenIndex, end = lastSignificantTokenIndex + 1;
    tokens = tokens.slice(start, end);
    tokens.forEach(function(token) {
        var tokenContent = tokenContentFromToken(token);
        content += tokenContent;
    });
    return content;
}
function contentFromNodes(nodes, augmentLeft, augmentRight, context) {
    var content = _constants.EMPTY_STRING;
    var tokens = context.tokens;
    var lastNode = last(nodes), firstNode = first(nodes), lastSignificantToken = lastNode.getLastSignificantToken(), firstSignificantToken = firstNode.getFirstSignificantToken(), lastSignificantTokenIndex = tokens.indexOf(lastSignificantToken), firstSignificantTokenIndex = tokens.indexOf(firstSignificantToken);
    var firstTokenIndex = firstSignificantTokenIndex, lastTokenIndex = lastSignificantTokenIndex; ///
    if (augmentLeft) {
        var previousTokenIndex = firstTokenIndex - 1;
        if (previousTokenIndex > -1) {
            var previousToken = tokens[previousTokenIndex], previousTokenSignificant = previousToken.isSignificant();
            if (!previousTokenSignificant) {
                firstTokenIndex--;
            }
        }
    }
    if (augmentRight) {
        var tokensLength = tokens.length, nextTokenIndex = lastTokenIndex + 1;
        if (nextTokenIndex < tokensLength) {
            var nextToken = tokens[nextTokenIndex], nextTokenSignificant = nextToken.isSignificant(), nextTokenEndOfLineToken = nextToken.isEndOfLineToken();
            if (nextTokenEndOfLineToken || !nextTokenSignificant) {
                lastTokenIndex++;
            }
        }
    }
    var start = firstTokenIndex, end = lastTokenIndex + 1;
    tokens = tokens.slice(start, end);
    tokens.forEach(function(token) {
        var tokenContent = tokenContentFromToken(token);
        content += tokenContent;
    });
    return content;
}
function contentFromNodeAndTokens(node, tokens) {
    var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var content = _constants.EMPTY_STRING;
    var firstSignificantToken = node.getFirstSignificantToken(), lastSignificantToken = node.getLastSignificantToken(), firstToken = firstSignificantToken, lastToken = lastSignificantToken, firstTokenIndex = tokens.indexOf(firstToken) + offset, lastTokenIndex = tokens.indexOf(lastToken);
    for(var index = firstTokenIndex; index <= lastTokenIndex; index++){
        var token = tokens[index], tokenContent = token.getContent();
        content += tokenContent;
    }
    return content;
}
function remainingContentFromNodeTokensAndOffset(node, tokens, offset) {
    var content = contentFromNodeAndTokens(node, tokens, offset), remainingContent = content; ///
    return remainingContent;
}
var _default = {
    contentFromNode: contentFromNode,
    contentFromNodes: contentFromNodes,
    contentFromNodeAndTokens: contentFromNodeAndTokens,
    remainingContentFromNodeTokensAndOffset: remainingContentFromNodeTokensAndOffset
};
function tokenContentFromToken(token) {
    var tokenContent = token.getContent();
    var type = token.getType();
    if (type === _tokenTypes.ESCAPED_TOKEN_TYPE) {
        var start = 1;
        tokenContent = tokenContent.substring(start);
    }
    return tokenContent;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvY29udGVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IEVTQ0FQRURfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi90b2tlblR5cGVzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIGxhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGVudEZyb21Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IGNvbnRlbnQgPSBFTVBUWV9TVFJJTkc7XG5cbiAgbGV0IHsgdG9rZW5zIH0gPSBjb250ZXh0O1xuXG4gIGNvbnN0IGxhc3RTaWduaWZpY2FudFRva2VuID0gbm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICBmaXJzdFNpZ25pZmljYW50VG9rZW4gPSBub2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gdG9rZW5zLmluZGV4T2YobGFzdFNpZ25pZmljYW50VG9rZW4pLFxuICAgICAgICBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRva2Vucy5pbmRleE9mKGZpcnN0U2lnbmlmaWNhbnRUb2tlbik7XG5cbiAgY29uc3Qgc3RhcnQgPSBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgIC8vL1xuICAgICAgICBlbmQgPSBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICsgMTtcblxuICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgdG9rZW5zLmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgY29uc3QgdG9rZW5Db250ZW50ID0gdG9rZW5Db250ZW50RnJvbVRva2VuKHRva2VuKTtcblxuICAgIGNvbnRlbnQgKz0gdG9rZW5Db250ZW50O1xuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRlbnRGcm9tTm9kZXMobm9kZXMsIGF1Z21lbnRMZWZ0LCBhdWdtZW50UmlnaHQsIGNvbnRleHQpIHtcbiAgbGV0IGNvbnRlbnQgPSBFTVBUWV9TVFJJTkc7XG5cbiAgbGV0IHsgdG9rZW5zIH0gPSBjb250ZXh0O1xuXG4gIGNvbnN0IGxhc3ROb2RlID0gbGFzdChub2RlcyksXG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0KG5vZGVzKSxcbiAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW4gPSBsYXN0Tm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICBmaXJzdFNpZ25pZmljYW50VG9rZW4gPSBmaXJzdE5vZGUuZ2V0Rmlyc3RTaWduaWZpY2FudFRva2VuKCksXG4gICAgICAgIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSB0b2tlbnMuaW5kZXhPZihsYXN0U2lnbmlmaWNhbnRUb2tlbiksXG4gICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gdG9rZW5zLmluZGV4T2YoZmlyc3RTaWduaWZpY2FudFRva2VuKTtcblxuICBsZXQgZmlyc3RUb2tlbkluZGV4ID0gZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgsICAvLy9cbiAgICAgIGxhc3RUb2tlbkluZGV4ID0gbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleDsgLy8vXG5cbiAgaWYgKGF1Z21lbnRMZWZ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNUb2tlbkluZGV4ID0gZmlyc3RUb2tlbkluZGV4IC0gMTtcblxuICAgIGlmIChwcmV2aW91c1Rva2VuSW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IHRva2Vuc1twcmV2aW91c1Rva2VuSW5kZXhdLFxuICAgICAgICAgICAgcHJldmlvdXNUb2tlblNpZ25pZmljYW50ID0gcHJldmlvdXNUb2tlbi5pc1NpZ25pZmljYW50KCk7XG5cbiAgICAgIGlmICghcHJldmlvdXNUb2tlblNpZ25pZmljYW50KSB7XG4gICAgICAgIGZpcnN0VG9rZW5JbmRleC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhdWdtZW50UmlnaHQpIHtcbiAgICBjb25zdCB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgIG5leHRUb2tlbkluZGV4ID0gbGFzdFRva2VuSW5kZXggKyAxO1xuXG4gICAgaWYgKG5leHRUb2tlbkluZGV4IDwgdG9rZW5zTGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0VG9rZW4gPSB0b2tlbnNbbmV4dFRva2VuSW5kZXhdLFxuICAgICAgICAgICAgbmV4dFRva2VuU2lnbmlmaWNhbnQgPSBuZXh0VG9rZW4uaXNTaWduaWZpY2FudCgpLFxuICAgICAgICAgICAgbmV4dFRva2VuRW5kT2ZMaW5lVG9rZW4gPSBuZXh0VG9rZW4uaXNFbmRPZkxpbmVUb2tlbigpO1xuXG4gICAgICBpZiAobmV4dFRva2VuRW5kT2ZMaW5lVG9rZW4gfHwgIW5leHRUb2tlblNpZ25pZmljYW50KSB7XG4gICAgICAgIGxhc3RUb2tlbkluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBmaXJzdFRva2VuSW5kZXgsICAvLy9cbiAgICAgICAgZW5kID0gbGFzdFRva2VuSW5kZXggKyAxO1xuXG4gIHRva2VucyA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcblxuICB0b2tlbnMuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICBjb25zdCB0b2tlbkNvbnRlbnQgPSB0b2tlbkNvbnRlbnRGcm9tVG9rZW4odG9rZW4pO1xuXG4gICAgY29udGVudCArPSB0b2tlbkNvbnRlbnQ7XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucywgb2Zmc2V0ID0gMCkge1xuICBsZXQgY29udGVudCA9IEVNUFRZX1NUUklORztcblxuICBjb25zdCBmaXJzdFNpZ25pZmljYW50VG9rZW4gPSBub2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICBsYXN0U2lnbmlmaWNhbnRUb2tlbiA9IG5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW4oKSxcbiAgICAgICAgZmlyc3RUb2tlbiA9IGZpcnN0U2lnbmlmaWNhbnRUb2tlbiwgLy8vXG4gICAgICAgIGxhc3RUb2tlbiA9IGxhc3RTaWduaWZpY2FudFRva2VuLCAvLy9cbiAgICAgICAgZmlyc3RUb2tlbkluZGV4ID0gdG9rZW5zLmluZGV4T2YoZmlyc3RUb2tlbikgKyBvZmZzZXQsICAvLy9cbiAgICAgICAgbGFzdFRva2VuSW5kZXggPSB0b2tlbnMuaW5kZXhPZihsYXN0VG9rZW4pO1xuXG4gIGZvciAobGV0IGluZGV4ID0gZmlyc3RUb2tlbkluZGV4OyBpbmRleCA8PSBsYXN0VG9rZW5JbmRleDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2luZGV4XSxcbiAgICAgICAgICB0b2tlbkNvbnRlbnQgPSB0b2tlbi5nZXRDb250ZW50KCk7XG5cbiAgICBjb250ZW50ICs9IHRva2VuQ29udGVudDtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtYWluaW5nQ29udGVudEZyb21Ob2RlVG9rZW5zQW5kT2Zmc2V0KG5vZGUsIHRva2Vucywgb2Zmc2V0KSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50RnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zLCBvZmZzZXQpLFxuICAgICAgICByZW1haW5pbmdDb250ZW50ID0gY29udGVudDsgLy8vXG5cbiAgcmV0dXJuIHJlbWFpbmluZ0NvbnRlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29udGVudEZyb21Ob2RlLFxuICBjb250ZW50RnJvbU5vZGVzLFxuICBjb250ZW50RnJvbU5vZGVBbmRUb2tlbnMsXG4gIHJlbWFpbmluZ0NvbnRlbnRGcm9tTm9kZVRva2Vuc0FuZE9mZnNldFxufTtcblxuZnVuY3Rpb24gdG9rZW5Db250ZW50RnJvbVRva2VuKHRva2VuKSB7XG4gIGxldCB0b2tlbkNvbnRlbnQgPSB0b2tlbi5nZXRDb250ZW50KCk7XG5cbiAgY29uc3QgdHlwZSA9IHRva2VuLmdldFR5cGUoKTtcblxuICBpZiAodHlwZSA9PT0gRVNDQVBFRF9UT0tFTl9UWVBFKSB7XG4gICAgY29uc3Qgc3RhcnQgPSAxO1xuXG4gICAgdG9rZW5Db250ZW50ID0gdG9rZW5Db250ZW50LnN1YnN0cmluZyhzdGFydCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5Db250ZW50O1xufVxuIl0sIm5hbWVzIjpbImNvbnRlbnRGcm9tTm9kZSIsImNvbnRlbnRGcm9tTm9kZUFuZFRva2VucyIsImNvbnRlbnRGcm9tTm9kZXMiLCJyZW1haW5pbmdDb250ZW50RnJvbU5vZGVUb2tlbnNBbmRPZmZzZXQiLCJmaXJzdCIsImFycmF5VXRpbGl0aWVzIiwibGFzdCIsIm5vZGUiLCJjb250ZXh0IiwiY29udGVudCIsIkVNUFRZX1NUUklORyIsInRva2VucyIsImxhc3RTaWduaWZpY2FudFRva2VuIiwiZ2V0TGFzdFNpZ25pZmljYW50VG9rZW4iLCJmaXJzdFNpZ25pZmljYW50VG9rZW4iLCJnZXRGaXJzdFNpZ25pZmljYW50VG9rZW4iLCJsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4IiwiaW5kZXhPZiIsImZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4Iiwic3RhcnQiLCJlbmQiLCJzbGljZSIsImZvckVhY2giLCJ0b2tlbiIsInRva2VuQ29udGVudCIsInRva2VuQ29udGVudEZyb21Ub2tlbiIsIm5vZGVzIiwiYXVnbWVudExlZnQiLCJhdWdtZW50UmlnaHQiLCJsYXN0Tm9kZSIsImZpcnN0Tm9kZSIsImZpcnN0VG9rZW5JbmRleCIsImxhc3RUb2tlbkluZGV4IiwicHJldmlvdXNUb2tlbkluZGV4IiwicHJldmlvdXNUb2tlbiIsInByZXZpb3VzVG9rZW5TaWduaWZpY2FudCIsImlzU2lnbmlmaWNhbnQiLCJ0b2tlbnNMZW5ndGgiLCJsZW5ndGgiLCJuZXh0VG9rZW5JbmRleCIsIm5leHRUb2tlbiIsIm5leHRUb2tlblNpZ25pZmljYW50IiwibmV4dFRva2VuRW5kT2ZMaW5lVG9rZW4iLCJpc0VuZE9mTGluZVRva2VuIiwib2Zmc2V0IiwiZmlyc3RUb2tlbiIsImxhc3RUb2tlbiIsImluZGV4IiwiZ2V0Q29udGVudCIsInJlbWFpbmluZ0NvbnRlbnQiLCJ0eXBlIiwiZ2V0VHlwZSIsIkVTQ0FQRURfVE9LRU5fVFlQRSIsInN1YnN0cmluZyJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztJQVNnQkEsZUFBZTtlQUFmQTs7SUFpRkFDLHdCQUF3QjtlQUF4QkE7O0lBekRBQyxnQkFBZ0I7ZUFBaEJBOztJQW9GaEIsT0FLRTtlQUxGOztJQVBnQkMsdUNBQXVDO2VBQXZDQTs7O3lCQTVHZTt5QkFFRjswQkFDTTtBQUVuQyxJQUFRQyxRQUFnQkMseUJBQWMsQ0FBOUJELE9BQU9FLE9BQVNELHlCQUFjLENBQXZCQztBQUVSLFNBQVNOLGdCQUFnQk8sSUFBSSxFQUFFQyxPQUFPO0lBQzNDLElBQUlDLFVBQVVDLHVCQUFZO0lBRTFCLElBQUksQUFBRUMsU0FBV0gsUUFBWEc7SUFFTixJQUFNQyx1QkFBdUJMLEtBQUtNLHVCQUF1QixJQUNuREMsd0JBQXdCUCxLQUFLUSx3QkFBd0IsSUFDckRDLDRCQUE0QkwsT0FBT00sT0FBTyxDQUFDTCx1QkFDM0NNLDZCQUE2QlAsT0FBT00sT0FBTyxDQUFDSDtJQUVsRCxJQUFNSyxRQUFRRCw0QkFDUkUsTUFBTUosNEJBQTRCO0lB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